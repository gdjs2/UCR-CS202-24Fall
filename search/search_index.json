{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CS202 - Advanced Operating System - Lab Session - 24 Fall Basic Info Hi\ud83d\udc4b, welcome to the course page for CS202 Advanced Operating System, Fall 2024 for UC Riverside, whose lecture is hosted by Prof. Heng Yin . The laboratory section would be hosted by me, Zhaoqi Xiao. Although we do not have an official Lab Session , you can try getting most of the help you need to complete your project from this website as well as addition documents provided here, or, from office hours. BTW, the time for my office hours would be: Monday 2pm - 4pm @ Zoom Or @ WCH 110 by appointment with email The Composition of Laboratory Session We will have three projects in total for the Lab Session: System Call Implementation Modifying the Scheduler Threads Prior to (or some time after) each Lab release, I would publish an instruction to help you get start with. Please be sure to check this website in a timely manner. Lab Tutorial Lab 1: System Call Implementation Tutorial Lab 2: Lottery and Stride Scheduling Debugging Tips Additional Links Course websites","title":"CS202 - Advanced Operating System - Lab Session - 24 Fall"},{"location":"#cs202-advanced-operating-system-lab-session-24-fall","text":"","title":"CS202 - Advanced Operating System - Lab Session - 24 Fall"},{"location":"#basic-info","text":"Hi\ud83d\udc4b, welcome to the course page for CS202 Advanced Operating System, Fall 2024 for UC Riverside, whose lecture is hosted by Prof. Heng Yin . The laboratory section would be hosted by me, Zhaoqi Xiao. Although we do not have an official Lab Session , you can try getting most of the help you need to complete your project from this website as well as addition documents provided here, or, from office hours. BTW, the time for my office hours would be: Monday 2pm - 4pm @ Zoom Or @ WCH 110 by appointment with email","title":"Basic Info"},{"location":"#the-composition-of-laboratory-session","text":"We will have three projects in total for the Lab Session: System Call Implementation Modifying the Scheduler Threads Prior to (or some time after) each Lab release, I would publish an instruction to help you get start with. Please be sure to check this website in a timely manner.","title":"The Composition of Laboratory Session"},{"location":"#lab-tutorial","text":"Lab 1: System Call Implementation Tutorial Lab 2: Lottery and Stride Scheduling Debugging Tips","title":"Lab Tutorial"},{"location":"#additional-links","text":"Course websites","title":"Additional Links"},{"location":"lab-tutorials/debug/","text":"Debugging Tips Before GDB Before stepping into gdb, I would recommand print statement first. Always think about whether a single print statement can solve your problem before you decide to use gdb. Using GDB with QEMU First, use command make qemu-gdb to compile and start qemu. $ make qemu-gdb riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -gdwarf-2 -MD -mcmodel=medany -fno-common -nostdlib ... balloc: first 800 blocks have been allocated balloc: write bitmap block at sector 45 *** Now run 'gdb' in another window. qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -global virtio-mmio.force-legacy=false -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -S -gdb tcp::25000 If you look at the Makefile , you can find the target definition at the end of file. K=kernel U=user ... qemu: $K/kernel fs.img $(QEMU) $(QEMUOPTS) .gdbinit: .gdbinit.tmpl-riscv sed \"s/:1234/:$(GDBPORT)/\" < $^ > $@ qemu-gdb: $K/kernel .gdbinit fs.img @echo \"*** Now run 'gdb' in another window.\" 1>&2 $(QEMU) $(QEMUOPTS) -S $(QEMUGDB) The difference between qemu and qemu-gdb is that qemu-gdb will generate a gdb configuration file .gdbinit , which will be further read by gdb for initialization. Therefore, please run following gdb-multiarch (or riscv64-linux-gnu-gdb or riscv64-unknown-elf-gdb ) under the same dicrectory so that they can find the initialization file. Run gdb-multiarch (or riscv64-linux-gnu-gdb or riscv64-unknown-elf-gdb ) in another window UNDER THE DIRECTORY OF XV6 . If you start gdb and see a warning of the form 'warning: File \"/home/xv6-riscv-UCR-CS202-Fall24/. gdbinit\" auto-loading has been declined by ...', edit ~/.gdbinit to add \"add-auto-load-safe-path...\" as suggected by the warning. $ gdb-multiarch GNU gdb (Ubuntu 15.0.50.20240403-0ubuntu1) 15.0.50.20240403-git ... The target architecture is set to \"riscv:rv64\". warning: No executable has been specified and target does not support determining executable automatically. Try using the \"file\" command. 0x0000000000001000 in ?? () (gdb) Afterwards, you can just use gdb as how you do for normal program. For example, if we want to set breakpoint at line 137 of file syscall.c : (gdb) b syscall.c:137 Breakpoint 1 at 0x8000283c: file kernel/syscall.c, line 137. Then you can input c to continue the program and it will stop at the breakpoint set. (gdb) c Continuing. [Switching to Thread 1.2] Thread 2 hit Breakpoint 1, syscall () at kernel/syscall.c:137 137 struct proc *p = myproc(); Refer to MIT's sildes about common-used gdb commands. Some are listed below: continue or c , continue executing the program untill the next breakpoint or the end of program. step or s , execute the program by one step, if this is a function call, step into it. next or n , execute the program by one step without stepping into a function call. finish , execute to the end of function. print <expression> or p <expression> : print the value of expression. display <expression> : automatically display the value of expression whenever stop. set <variable> = <value> : modify the value of variable. backtrace or bt : show the call stack. info frame : show information about current frame. info locals : how all local variables for current frame. list or l : show the source code. list <location> : show the source code at specific location.","title":"Debugging Tips"},{"location":"lab-tutorials/debug/#debugging-tips","text":"","title":"Debugging Tips"},{"location":"lab-tutorials/debug/#before-gdb","text":"Before stepping into gdb, I would recommand print statement first. Always think about whether a single print statement can solve your problem before you decide to use gdb.","title":"Before GDB"},{"location":"lab-tutorials/debug/#using-gdb-with-qemu","text":"First, use command make qemu-gdb to compile and start qemu. $ make qemu-gdb riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -gdwarf-2 -MD -mcmodel=medany -fno-common -nostdlib ... balloc: first 800 blocks have been allocated balloc: write bitmap block at sector 45 *** Now run 'gdb' in another window. qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -global virtio-mmio.force-legacy=false -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -S -gdb tcp::25000 If you look at the Makefile , you can find the target definition at the end of file. K=kernel U=user ... qemu: $K/kernel fs.img $(QEMU) $(QEMUOPTS) .gdbinit: .gdbinit.tmpl-riscv sed \"s/:1234/:$(GDBPORT)/\" < $^ > $@ qemu-gdb: $K/kernel .gdbinit fs.img @echo \"*** Now run 'gdb' in another window.\" 1>&2 $(QEMU) $(QEMUOPTS) -S $(QEMUGDB) The difference between qemu and qemu-gdb is that qemu-gdb will generate a gdb configuration file .gdbinit , which will be further read by gdb for initialization. Therefore, please run following gdb-multiarch (or riscv64-linux-gnu-gdb or riscv64-unknown-elf-gdb ) under the same dicrectory so that they can find the initialization file. Run gdb-multiarch (or riscv64-linux-gnu-gdb or riscv64-unknown-elf-gdb ) in another window UNDER THE DIRECTORY OF XV6 . If you start gdb and see a warning of the form 'warning: File \"/home/xv6-riscv-UCR-CS202-Fall24/. gdbinit\" auto-loading has been declined by ...', edit ~/.gdbinit to add \"add-auto-load-safe-path...\" as suggected by the warning. $ gdb-multiarch GNU gdb (Ubuntu 15.0.50.20240403-0ubuntu1) 15.0.50.20240403-git ... The target architecture is set to \"riscv:rv64\". warning: No executable has been specified and target does not support determining executable automatically. Try using the \"file\" command. 0x0000000000001000 in ?? () (gdb) Afterwards, you can just use gdb as how you do for normal program. For example, if we want to set breakpoint at line 137 of file syscall.c : (gdb) b syscall.c:137 Breakpoint 1 at 0x8000283c: file kernel/syscall.c, line 137. Then you can input c to continue the program and it will stop at the breakpoint set. (gdb) c Continuing. [Switching to Thread 1.2] Thread 2 hit Breakpoint 1, syscall () at kernel/syscall.c:137 137 struct proc *p = myproc(); Refer to MIT's sildes about common-used gdb commands. Some are listed below: continue or c , continue executing the program untill the next breakpoint or the end of program. step or s , execute the program by one step, if this is a function call, step into it. next or n , execute the program by one step without stepping into a function call. finish , execute to the end of function. print <expression> or p <expression> : print the value of expression. display <expression> : automatically display the value of expression whenever stop. set <variable> = <value> : modify the value of variable. backtrace or bt : show the call stack. info frame : show information about current frame. info locals : how all local variables for current frame. list or l : show the source code. list <location> : show the source code at specific location.","title":"Using GDB with QEMU"},{"location":"lab-tutorials/lab1/","text":"Lab 1 - System Call Implementation Before Start Xv6 is an open-source project built by MIT. It is a simple Unix-like OS for educational purpose. It has its source code published on Github and it is still maintained from time to time nowadays. In order to keep the consistency of the files you pull down, you are required to clone the XV6 files from our forked repository . As you can notice to, we use a risc-v version of xv6 here. Most of modern laptops or PCs we use are based on X86-64 or ARM. Therefore, in order to run xv6, we need an emulator, which could provide a risc-v execution environment on our local machine. We would introduce some supplementary resources for you. Feel free to check them when you meet difficulties finishing your project. Debug for xv6 xv6 Tutorial xv6 Book Compile & Boot Before you start modifying the code, you need to know how to compile and run the code of xv6. As we introduced before, we need a risc-v toolchain to compile the source code and a risc-v emulator to provide the execution environment. Prior to stepping into installing the risc-v toolchain and emulator, we would suggest you finishing this project on a Unix-like environment, which includes all Linux distribution (e.g., Ubuntu, Arch, ...), macOS and so on. If you are using Windows, you can have a Linux subsystem running on your local machine though Windows Subsystem Linux, WSL . In order to fulfill the some virtualization requirements, you should try WSL 2 instead of WSL. We would provide the tested command line & instructions based on a Ubuntu 24.04. For other Linux distribution and macOS, please refer to your own Package Management System (like pacman for arch and brew for macOS) for issues you may meet. Tools Run the following command in your command line: Debian or Ubuntu $ sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu Arch Linux $ sudo pacman -S riscv64-linux-gnu-binutils riscv64-linux-gnu-gcc riscv64-linux-gnu-gdb qemu-emulators-full macOS Install developer tools if you haven't: $ xcode-select --install Next, install Homebrew , a package manager for macOS if you haven't: $ /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" Next, install the RISC-V compiler toolchain : $ brew tap riscv/riscv $ brew install riscv-tools The brew formula may not link into /usr/local. You will need to update your shell's rc file (e.g. ~/.bashrc ) to add the appropriate directory to $PATH . Finally install QEMU: $ brew install qemu Testing your Installation Run the following command to see whether it can give you the version number for the programs: $ qemu-system-riscv64 --version QEMU emulator version 8.2.2 (Debian 1:8.2.2+ds-0ubuntu1.2) ... And at least one RISC-V version of GCC: $ riscv64-linux-gnu-gcc --version riscv64-linux-gnu-gcc (Ubuntu 13.2.0-23ubuntu4) 13.2.0 ... $ riscv64-unknown-elf-gcc --version $ riscv64-unknown-linux-gnu-gcc --version Compile Fetch the source code from our xv6 repository : $ git clone https://github.com/gdjs2/xv6-riscv-UCR-CS202-Fall24.git Cloning into 'xv6-riscv-UCR-CS202-Fall24'... Change directory to the one containing xv6. $ cd xv6-riscv-UCR-CS202-Fall24 Build and run xv6: $ make qemu riscv64-linux-gnu-gcc -c -o kernel/entry.o kernel/entry.S riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb ... riscv64-linux-gnu-objdump -S user/_zombie > user/zombie.asm riscv64-linux-gnu-objdump -t user/_zombie | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$/d' > user/zombie.sym mkfs/mkfs fs.img README user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie nmeta 46 (boot, super, log blocks 30 inode blocks 13, bitmap blocks 1) blocks 1954 total 2000 balloc: first 767 blocks have been allocated balloc: write bitmap block at sector 45 qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -global virtio-mmio.force-legacy=false -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 xv6 kernel is booting hart 2 starting hart 1 starting init: starting sh $ Now, xv6-riscv has been compiled and a bash is running. If you type ls at the prompt, you should see output similar to the following: $ ls . 1 1 1024 .. 1 1 1024 README 2 2 2292 cat 2 3 34264 echo 2 4 33184 forktest 2 5 16184 grep 2 6 37520 init 2 7 33648 kill 2 8 33104 ln 2 9 32920 ls 2 10 36288 mkdir 2 11 33160 rm 2 12 33152 sh 2 13 54728 stressfs 2 14 34048 usertests 2 15 179352 grind 2 16 49400 wc 2 17 35216 zombie 2 18 32528 console 3 19 0 There are the files that mkfs includes in the initial file system; most are programs you can run. To quit qemu type Ctrl-a x (press Ctrl and a at the same time, followed by x ) Tips : Print state is always a very powerful tool to debug. But if you truly prefer gdb, please refer to here and Using gdb section of here . Primary Instruction We would like to divide the instruction for our lab into two levels-Primary and Advanced. You can choose primary one if you want to challenge yourself. The primary instruction will tell you what you need to do and where to find corresponding information. The advanced one, instead, is more like a step-by-step instruction to help you go towards the goal. I'd highly encourage you using primary first and go for the advanced instruction if you can't figure it out by yourself. Read section 4.3 and 4.4 of xv6 book . Define your customized syscall and its number in kernel/syscall.h . Define corresponding prototype for kernel space function in kernel/syscall.c . Add the mapping relationship between the syscall number and kernel space function in syscalls map of kernel/syscall.c . Implement your system call function in kernel/sysproc.c . Modify usys.pl script, which will generate usys.S containing the system call stubs under user space. Add user space syscall prototype in user/user.h . Write a user space program to show your result. Advanced Instruction Read Section 4.3 and 4.4!! Read these two sections from xv6 book to help you write report! Modification in Kernel Space Define SYSCALL and Number Append single line to kernel/syscall.h , which defines the syscall name and syscall number (you can choose any vacant number, I just randomly choose 33 here. Don't choose the one same with me, or I would assume you just copy the code from the instruction). // System call numbers #define SYS_fork 1 #define SYS_exit 2 ... #define SYS_close 21 #define SYS_info 33 Define Kernel Space Prototype In kernel/syscall.c , find comment about prototypes for the functions... and append one function prototype for your system call to this code section. // Prototypes for the functions that handle system calls. extern uint64 sys_fork(void); extern uint64 sys_exit(void); ... extern uint64 sys_close(void); extern uint64 sys_info(void); Several questions: 1. Should this function must be named as sys_info() ? 2. Why the parameters defined here is void instead of int ? 3. What is extern function in C program? Add a Mapping between SYSCALL# and Prototype In order to tell the OS, which function should be called when you meet specific syscall number, we need to add a mapping between the number and the function prototype. This mapping information is encoded in a static-generated array. We need to insert the address of function into the slot in the array indexed by the syscall number. Search for comment An array mapping syscall numbers from syscall.h in kernel/syscall.c and insert one element into this array. // An array mapping syscall numbers from syscall.h // to the function that handles the system call. static uint64 (*syscalls[])(void) = { [SYS_fork] sys_fork, [SYS_exit] sys_exit, [SYS_wait] sys_wait, ... [SYS_close] sys_close, [SYS_info] sys_info, }; Implement SYSCALL You can check existing implemented syscalls from kernel/sysproc.c and what you need to do is implementing your customized syscall function here. The way you get arguments in syscall function is different from the regular way in C/C++ program (directly from certain offset to stack/base pointer and heap). You can refer to existing function implementation about how to retrieve the arguments. Also, you may need to modify exist structures or functions to help you implement your syscall. Modification in User Space Modify usys.pl usys.pl is responsible for generating usys.S , which contains all syscall stubs in user space. Therefore, we need to add our customized syscall into this script as well. entry(\"fork\"); ... entry(\"info\"); Add User Space Prototype We need to add a function prototype in user space for program to call the syscall. They are at user/user.h . Under the syscall section in this file, append your prototype: // system calls int fork(void); ... int uptime(void); int info(int) User Space Program Finally, you may need a user space program to help you check your syscall implementation. We provide a simple version here: #include \"kernel/types.h\" #include \"kernel/stat.h\" #include \"user/user.h\" int main() { printf(\"Total number of system calls made by current process: %d\\n\", info(2)); printf(\"Total number of processes: %d\\n\", info(1)); printf(\"Total number of system calls made by current process: %d\\n\", info(2)); printf(\"Total number of memory pages used by current process: %d\\n\", info(3)); printf(\"Total number of system calls made by current process: %d\\n\", info(2)); exit(0); } You need to put this source file under /user/ . Assume you have this code stored as file test_info.c under /user and you need to futher add this file into the makefile , which tells which files should be compiled. In Makefile , find variable UPROGS and append our user space program to it. UPROGS=\\ $U/_cat\\ $U/_echo\\ $U/_forktest\\ ... $U/_zombie\\ $U/_test_info\\ Now you can recompile the xv6 and run the program test_info in the bash. $ ./test_info Total number of system calls made by current process: 3 Total number of processes: 3 Total number of system calls made by current process: 90 Total number of memory pages used by current process: 4 Total number of system calls made by current process: 205 Please include a screenshot and explanation of execution result in your report.","title":"Lab 1 - System Call Implementation"},{"location":"lab-tutorials/lab1/#lab-1-system-call-implementation","text":"","title":"Lab 1 - System Call Implementation"},{"location":"lab-tutorials/lab1/#before-start","text":"Xv6 is an open-source project built by MIT. It is a simple Unix-like OS for educational purpose. It has its source code published on Github and it is still maintained from time to time nowadays. In order to keep the consistency of the files you pull down, you are required to clone the XV6 files from our forked repository . As you can notice to, we use a risc-v version of xv6 here. Most of modern laptops or PCs we use are based on X86-64 or ARM. Therefore, in order to run xv6, we need an emulator, which could provide a risc-v execution environment on our local machine. We would introduce some supplementary resources for you. Feel free to check them when you meet difficulties finishing your project. Debug for xv6 xv6 Tutorial xv6 Book","title":"Before Start"},{"location":"lab-tutorials/lab1/#compile-boot","text":"Before you start modifying the code, you need to know how to compile and run the code of xv6. As we introduced before, we need a risc-v toolchain to compile the source code and a risc-v emulator to provide the execution environment. Prior to stepping into installing the risc-v toolchain and emulator, we would suggest you finishing this project on a Unix-like environment, which includes all Linux distribution (e.g., Ubuntu, Arch, ...), macOS and so on. If you are using Windows, you can have a Linux subsystem running on your local machine though Windows Subsystem Linux, WSL . In order to fulfill the some virtualization requirements, you should try WSL 2 instead of WSL. We would provide the tested command line & instructions based on a Ubuntu 24.04. For other Linux distribution and macOS, please refer to your own Package Management System (like pacman for arch and brew for macOS) for issues you may meet.","title":"Compile &amp; Boot"},{"location":"lab-tutorials/lab1/#tools","text":"Run the following command in your command line:","title":"Tools"},{"location":"lab-tutorials/lab1/#debian-or-ubuntu","text":"$ sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu","title":"Debian or Ubuntu"},{"location":"lab-tutorials/lab1/#arch-linux","text":"$ sudo pacman -S riscv64-linux-gnu-binutils riscv64-linux-gnu-gcc riscv64-linux-gnu-gdb qemu-emulators-full","title":"Arch Linux"},{"location":"lab-tutorials/lab1/#macos","text":"Install developer tools if you haven't: $ xcode-select --install Next, install Homebrew , a package manager for macOS if you haven't: $ /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" Next, install the RISC-V compiler toolchain : $ brew tap riscv/riscv $ brew install riscv-tools The brew formula may not link into /usr/local. You will need to update your shell's rc file (e.g. ~/.bashrc ) to add the appropriate directory to $PATH . Finally install QEMU: $ brew install qemu","title":"macOS"},{"location":"lab-tutorials/lab1/#testing-your-installation","text":"Run the following command to see whether it can give you the version number for the programs: $ qemu-system-riscv64 --version QEMU emulator version 8.2.2 (Debian 1:8.2.2+ds-0ubuntu1.2) ... And at least one RISC-V version of GCC: $ riscv64-linux-gnu-gcc --version riscv64-linux-gnu-gcc (Ubuntu 13.2.0-23ubuntu4) 13.2.0 ... $ riscv64-unknown-elf-gcc --version $ riscv64-unknown-linux-gnu-gcc --version","title":"Testing your Installation"},{"location":"lab-tutorials/lab1/#compile","text":"Fetch the source code from our xv6 repository : $ git clone https://github.com/gdjs2/xv6-riscv-UCR-CS202-Fall24.git Cloning into 'xv6-riscv-UCR-CS202-Fall24'... Change directory to the one containing xv6. $ cd xv6-riscv-UCR-CS202-Fall24 Build and run xv6: $ make qemu riscv64-linux-gnu-gcc -c -o kernel/entry.o kernel/entry.S riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb ... riscv64-linux-gnu-objdump -S user/_zombie > user/zombie.asm riscv64-linux-gnu-objdump -t user/_zombie | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$/d' > user/zombie.sym mkfs/mkfs fs.img README user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie nmeta 46 (boot, super, log blocks 30 inode blocks 13, bitmap blocks 1) blocks 1954 total 2000 balloc: first 767 blocks have been allocated balloc: write bitmap block at sector 45 qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -global virtio-mmio.force-legacy=false -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 xv6 kernel is booting hart 2 starting hart 1 starting init: starting sh $ Now, xv6-riscv has been compiled and a bash is running. If you type ls at the prompt, you should see output similar to the following: $ ls . 1 1 1024 .. 1 1 1024 README 2 2 2292 cat 2 3 34264 echo 2 4 33184 forktest 2 5 16184 grep 2 6 37520 init 2 7 33648 kill 2 8 33104 ln 2 9 32920 ls 2 10 36288 mkdir 2 11 33160 rm 2 12 33152 sh 2 13 54728 stressfs 2 14 34048 usertests 2 15 179352 grind 2 16 49400 wc 2 17 35216 zombie 2 18 32528 console 3 19 0 There are the files that mkfs includes in the initial file system; most are programs you can run. To quit qemu type Ctrl-a x (press Ctrl and a at the same time, followed by x ) Tips : Print state is always a very powerful tool to debug. But if you truly prefer gdb, please refer to here and Using gdb section of here .","title":"Compile"},{"location":"lab-tutorials/lab1/#primary-instruction","text":"We would like to divide the instruction for our lab into two levels-Primary and Advanced. You can choose primary one if you want to challenge yourself. The primary instruction will tell you what you need to do and where to find corresponding information. The advanced one, instead, is more like a step-by-step instruction to help you go towards the goal. I'd highly encourage you using primary first and go for the advanced instruction if you can't figure it out by yourself. Read section 4.3 and 4.4 of xv6 book . Define your customized syscall and its number in kernel/syscall.h . Define corresponding prototype for kernel space function in kernel/syscall.c . Add the mapping relationship between the syscall number and kernel space function in syscalls map of kernel/syscall.c . Implement your system call function in kernel/sysproc.c . Modify usys.pl script, which will generate usys.S containing the system call stubs under user space. Add user space syscall prototype in user/user.h . Write a user space program to show your result.","title":"Primary Instruction"},{"location":"lab-tutorials/lab1/#advanced-instruction","text":"","title":"Advanced Instruction"},{"location":"lab-tutorials/lab1/#read-section-43-and-44","text":"Read these two sections from xv6 book to help you write report!","title":"Read Section 4.3 and 4.4!!"},{"location":"lab-tutorials/lab1/#modification-in-kernel-space","text":"","title":"Modification in Kernel Space"},{"location":"lab-tutorials/lab1/#define-syscall-and-number","text":"Append single line to kernel/syscall.h , which defines the syscall name and syscall number (you can choose any vacant number, I just randomly choose 33 here. Don't choose the one same with me, or I would assume you just copy the code from the instruction). // System call numbers #define SYS_fork 1 #define SYS_exit 2 ... #define SYS_close 21 #define SYS_info 33","title":"Define SYSCALL and Number"},{"location":"lab-tutorials/lab1/#define-kernel-space-prototype","text":"In kernel/syscall.c , find comment about prototypes for the functions... and append one function prototype for your system call to this code section. // Prototypes for the functions that handle system calls. extern uint64 sys_fork(void); extern uint64 sys_exit(void); ... extern uint64 sys_close(void); extern uint64 sys_info(void); Several questions: 1. Should this function must be named as sys_info() ? 2. Why the parameters defined here is void instead of int ? 3. What is extern function in C program?","title":"Define Kernel Space Prototype"},{"location":"lab-tutorials/lab1/#add-a-mapping-between-syscall-and-prototype","text":"In order to tell the OS, which function should be called when you meet specific syscall number, we need to add a mapping between the number and the function prototype. This mapping information is encoded in a static-generated array. We need to insert the address of function into the slot in the array indexed by the syscall number. Search for comment An array mapping syscall numbers from syscall.h in kernel/syscall.c and insert one element into this array. // An array mapping syscall numbers from syscall.h // to the function that handles the system call. static uint64 (*syscalls[])(void) = { [SYS_fork] sys_fork, [SYS_exit] sys_exit, [SYS_wait] sys_wait, ... [SYS_close] sys_close, [SYS_info] sys_info, };","title":"Add a Mapping between SYSCALL# and Prototype"},{"location":"lab-tutorials/lab1/#implement-syscall","text":"You can check existing implemented syscalls from kernel/sysproc.c and what you need to do is implementing your customized syscall function here. The way you get arguments in syscall function is different from the regular way in C/C++ program (directly from certain offset to stack/base pointer and heap). You can refer to existing function implementation about how to retrieve the arguments. Also, you may need to modify exist structures or functions to help you implement your syscall.","title":"Implement SYSCALL"},{"location":"lab-tutorials/lab1/#modification-in-user-space","text":"","title":"Modification in User Space"},{"location":"lab-tutorials/lab1/#modify-usyspl","text":"usys.pl is responsible for generating usys.S , which contains all syscall stubs in user space. Therefore, we need to add our customized syscall into this script as well. entry(\"fork\"); ... entry(\"info\");","title":"Modify usys.pl"},{"location":"lab-tutorials/lab1/#add-user-space-prototype","text":"We need to add a function prototype in user space for program to call the syscall. They are at user/user.h . Under the syscall section in this file, append your prototype: // system calls int fork(void); ... int uptime(void); int info(int)","title":"Add User Space Prototype"},{"location":"lab-tutorials/lab1/#user-space-program","text":"Finally, you may need a user space program to help you check your syscall implementation. We provide a simple version here: #include \"kernel/types.h\" #include \"kernel/stat.h\" #include \"user/user.h\" int main() { printf(\"Total number of system calls made by current process: %d\\n\", info(2)); printf(\"Total number of processes: %d\\n\", info(1)); printf(\"Total number of system calls made by current process: %d\\n\", info(2)); printf(\"Total number of memory pages used by current process: %d\\n\", info(3)); printf(\"Total number of system calls made by current process: %d\\n\", info(2)); exit(0); } You need to put this source file under /user/ . Assume you have this code stored as file test_info.c under /user and you need to futher add this file into the makefile , which tells which files should be compiled. In Makefile , find variable UPROGS and append our user space program to it. UPROGS=\\ $U/_cat\\ $U/_echo\\ $U/_forktest\\ ... $U/_zombie\\ $U/_test_info\\ Now you can recompile the xv6 and run the program test_info in the bash. $ ./test_info Total number of system calls made by current process: 3 Total number of processes: 3 Total number of system calls made by current process: 90 Total number of memory pages used by current process: 4 Total number of system calls made by current process: 205 Please include a screenshot and explanation of execution result in your report.","title":"User Space Program"},{"location":"lab-tutorials/lab2/","text":"Lab 2 - Scheduler, Lottery and Stride Before Start Take a look at our project repo . We have a new scheduler-lab branch published. In this lab, you need implement your work based on this branch. Also, get overall idea for these two scheduling strategy: Lottery Scheduling Stride Scheduling Pull the Repo Clone the repo to your local machine. $ git clone https://github.com/gdjs2/xv6-riscv-UCR-CS202-Fall24.git Change directory and checkout to scheduler-lab branch. $ git checkout scheduler-lab If you receive error like: fatal: detected dubious ownership in repository at... just follow the instruction mark the directory as safe. Let's first see what has been done for our project. Makefile In Makefile , we have four mofidifcations: Add a source file and objective file random.o, which is a Linear congruential generator (LCG) for generating random numbers in lottery scheduler. Add a macro deciding which scheduler to use in compiling. Add a user space program to test different schedulers. Change the cpu counts to one. (why we need do this?) diff --git a/Makefile b/Makefile index f8c820e..b2ce8c0 100644 --- a/Makefile +++ b/Makefile @@ -28,7 +28,8 @@ OBJS = \\ $K/sysfile.o \\ $K/kernelvec.o \\ $K/plic.o \\ - $K/virtio_disk.o + $K/virtio_disk.o \\ + $K/random.o # riscv64-unknown-elf- or riscv64-linux-gnu- # perhaps in /opt/riscv/bin @@ -78,6 +79,13 @@ ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),) CFLAGS += -fno-pie -nopie endif +# Add lottery and stride scheduler +ifeq ($(SCHEDULER), LOTTERY) + CFLAGS += -DSCHEDULER=LOTTERY +else ifeq ($(SCHEDULER), STRIDE) + CFLAGS += -DSCHEDULER=STRIDE +endif + LDFLAGS = -z max-page-size=4096 $K/kernel: $(OBJS) $K/kernel.ld $U/initcode @@ -139,6 +147,7 @@ UPROGS=\\ $U/_grind\\ $U/_wc\\ $U/_zombie\\ + $U/_test_scheduler\\ fs.img: mkfs/mkfs README $(UPROGS) mkfs/mkfs fs.img README $(UPROGS) @@ -160,7 +169,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \\ then echo \"-gdb tcp::$(GDBPORT)\"; \\ else echo \"-s -p $(GDBPORT)\"; fi) ifndef CPUS -CPUS := 3 +CPUS := 1 endif QEMUOPTS = -machine virt -bios none -kernel $K/kernel -m 128M -smp $(CPUS) -nographic /kernel/defs.h In /kernel/defs.h , we have two modifications: 1. Add declaration for two kernel functions. void proc_set_tickets(int) is for setting tickets for current process and int getticks(int pid) is for getting ticks spent on particular process specified by pid . 2. Add function interfaces for random.o - uint random(void) for generating random numbers and void srand(uint64) for specifying the seed of randomization. diff --git a/kernel/defs.h b/kernel/defs.h index d1b6bb9..03b3d6c 100644 --- a/kernel/defs.h +++ b/kernel/defs.h @@ -106,6 +106,8 @@ void yield(void); int either_copyout(int user_dst, uint64 dst, void *src, uint64 len); int either_copyin(void *dst, int user_src, uint64 src, uint64 len); void procdump(void); +void proc_set_tickets(int); +int getticks(int pid); // swtch.S void swtch(struct context*, struct context*); @@ -187,3 +189,7 @@ void virtio_disk_intr(void); // number of elements in fixed-size array #define NELEM(x) (sizeof(x)/sizeof((x)[0])) + +// random.c +uint random(void); +void srand(uint64); \\ No newline at end of file /kernel/param.h In /kernel/param.h , we defined several constants for schedulers: STRIDE1 : the total stride in stride scheduler, $2^{16}$ by default DEFAULT_TICKS : the default TICKETS for process, $2^{10}=1024$ by default. LOTTERY and STRIDE : variables for conditional compilation. diff --git a/kernel/param.h b/kernel/param.h index 80ec6d3..f998f5d 100644 --- a/kernel/param.h +++ b/kernel/param.h @@ -12,4 +12,7 @@ #define FSSIZE 2000 // size of file system in blocks #define MAXPATH 128 // maximum file path name #define USERSTACK 1 // user stack pages - +#define STRIDE1 (1<<16) // stride value for stride scheduling +#define DEFAULT_TICKS (1<<10) // default time slice for stride scheduling +#define LOTTERY 1 // lottery scheduling +#define STRIDE 2 // stride scheduling /kernel/proc.c This is the most complex part and what you need to do is implementing two scheduler functions in this file, referring to TODO symbols. New Member Vars We have four member variables defined in struct proc for schedulers- tickets , stride , pass and ticks . For their definition and usage, refer to the papers . --- a/kernel/proc.c +++ b/kernel/proc.c @@ -124,6 +124,10 @@ allocproc(void) found: p->pid = allocpid(); p->state = USED; + p->tickets = DEFAULT_TICKS; + p->stride = STRIDE1 / p->tickets; + p->pass = p->stride; + p->ticks = 0; // Allocate a trapframe page. if((p->trapframe = (struct trapframe *)kalloc()) == 0){ @@ -169,6 +173,10 @@ freeproc(struct proc *p) p->killed = 0; p->xstate = 0; p->state = UNUSED; + p->tickets = 0; + p->stride = 0; + p->pass = 0; + p->ticks = 0; } Scheduler Part WHAT YOU NEED TO DO in this project is finishing the two scheduler() functions in this file and test them by provided user space program. The original void scheduler(void) function is a Round Robin (RR) scheduling. void scheduler(void) { struct proc *p; struct cpu *c = mycpu(); c->proc = 0; for(;;){ // The most recent process to run may have had interrupts // turned off; enable them to avoid a deadlock if all // processes are waiting. ... } } } The outer for(;;) loop will be launched when each cpu starts. Therefore, in the default implementation, you can find that the function keeps finding the available (i.e., RUNNABLE ) process and run it whenever the scheduler finds one. This is known as RR scheduling. It's not hard to imagine that, the processes will be executed evenly and they will have almost the same execution time. acquire(&p->lock); ... release(&p->lock); Acquire and release the process lock when you need to access/modify the members in structure p to avoid consistency issues. intr_on() is used for enabling the interrupts in OS. asm volatile(\"wfi\") is used for inserting a assembly language wfi , which puts current CPU to idle and waiting till next interrput. @@ -441,6 +449,7 @@ wait(uint64 addr) // - swtch to start running that process. // - eventually that process transfers control // via swtch back to the scheduler. +#if !defined(SCHEDULER) || (SCHEDULER != LOTTERY && SCHEDULER != STRIDE) void scheduler(void) { @@ -464,6 +473,7 @@ scheduler(void) p->state = RUNNING; c->proc = p; swtch(&c->context, &p->context); + ++p->ticks; // Increment the tick count for the process. // Process is done running for now. // It should have changed its p->state before coming back. @@ -480,6 +490,26 @@ scheduler(void) } } +#elif SCHEDULER == LOTTERY +/** + * TODO: Implement the lottery scheduler. + */ +void +scheduler(void) +{ + +} +#elif SCHEDULER == STRIDE +/** + * TODO: Implement the stride scheduler. + */ +void +scheduler(void) +{ + +} +#endif + // Switch to scheduler. Must hold only p->lock // and have changed proc->state. Saves and restores // intena because intena is a property of this @@ -693,3 +723,24 @@ procdump(void) printf(\"\\n\"); } } + Two Kernel Functions Two kernel functions implementation for setting tickets and getting ticks, referring here for details. +void proc_set_tickets(int tickets) { + struct proc *p = myproc(); + acquire(&p->lock); + p->tickets = tickets; + p->stride = STRIDE1 / p->tickets; + release(&p->lock); +} + +int getticks(int pid) { + struct proc *p; + for (p = proc; p < &proc[NPROC]; p++) { + acquire(&p->lock); + if (p->pid == pid) { + release(&p->lock); + return p->ticks; + } + release(&p->lock); + } + return -1; +} \\ No newline at end of file /kernel/proc.h Add necessary attributes for structure struct proc , refer here for details. diff --git a/kernel/proc.h b/kernel/proc.h index d021857..d5e5fc5 100644 --- a/kernel/proc.h +++ b/kernel/proc.h @@ -91,6 +91,10 @@ struct proc { int killed; // If non-zero, have been killed int xstate; // Exit status to be returned to parent's wait int pid; // Process ID + uint tickets; + uint stride; + uint pass; + uint ticks; // wait_lock must be held when using this: struct proc *parent; // Parent process /kernel/random.c Source file for random number generation. You would use them in lottery scheduling. Refer here for details. diff --git a/kernel/random.c b/kernel/random.c new file mode 100644 index 0000000..53334b0 --- /dev/null +++ b/kernel/random.c @@ -0,0 +1,12 @@ +#include \"types.h\" + +static uint64 seed = 1; + +uint random(void) { + seed = seed * 6364136223846793005ULL + 1; + return (seed >> 32) & 0x7fffffff; +} + +void srand(uint64 new_seed) { + seed = new_seed; +} \\ No newline at end of file /kernel/syscall.c Mandatory system calls definition, you have learned them in Lab 1. diff --git a/kernel/syscall.c b/kernel/syscall.c index ed65409..217a31b 100644 --- a/kernel/syscall.c +++ b/kernel/syscall.c @@ -101,6 +101,8 @@ extern uint64 sys_unlink(void); extern uint64 sys_link(void); extern uint64 sys_mkdir(void); extern uint64 sys_close(void); +extern uint64 sys_settickets(void); +extern uint64 sys_getticks(void); // An array mapping syscall numbers from syscall.h // to the function that handles the system call. @@ -126,6 +128,8 @@ static uint64 (*syscalls[])(void) = { [SYS_link] sys_link, [SYS_mkdir] sys_mkdir, [SYS_close] sys_close, +[SYS_settickets] sys_settickets, +[SYS_getticks] sys_getticks, }; void /kernel/syscall.h Same to above. diff --git a/kernel/syscall.h b/kernel/syscall.h index bc5f356..19fc543 100644 --- a/kernel/syscall.h +++ b/kernel/syscall.h @@ -1,22 +1,24 @@ // System call numbers -#define SYS_fork 1 -#define SYS_exit 2 -#define SYS_wait 3 -#define SYS_pipe 4 -#define SYS_read 5 -#define SYS_kill 6 -#define SYS_exec 7 -#define SYS_fstat 8 -#define SYS_chdir 9 -#define SYS_dup 10 -#define SYS_getpid 11 -#define SYS_sbrk 12 -#define SYS_sleep 13 -#define SYS_uptime 14 -#define SYS_open 15 -#define SYS_write 16 -#define SYS_mknod 17 -#define SYS_unlink 18 -#define SYS_link 19 -#define SYS_mkdir 20 -#define SYS_close 21 +#define SYS_fork 1 +#define SYS_exit 2 +#define SYS_wait 3 +#define SYS_pipe 4 +#define SYS_read 5 +#define SYS_kill 6 +#define SYS_exec 7 +#define SYS_fstat 8 +#define SYS_chdir 9 +#define SYS_dup 10 +#define SYS_getpid 11 +#define SYS_sbrk 12 +#define SYS_sleep 13 +#define SYS_uptime 14 +#define SYS_open 15 +#define SYS_write 16 +#define SYS_mknod 17 +#define SYS_unlink 18 +#define SYS_link 19 +#define SYS_mkdir 20 +#define SYS_close 21 +#define SYS_settickets 22 +#define SYS_getticks 23 /kernel/sysproc.c System call implementations. diff --git a/kernel/sysproc.c b/kernel/sysproc.c index 3b4d5bd..e53385f 100644 --- a/kernel/sysproc.c +++ b/kernel/sysproc.c @@ -91,3 +91,23 @@ sys_uptime(void) release(&tickslock); return xticks; } + +uint64 +sys_settickets(void) +{ + int tickets; + argint(0, &tickets); + if (tickets < 1) { + return -1; + } + proc_set_tickets(tickets); + return 0; +} + +uint64 +sys_getticks(void) +{ + int pid; + argint(0, &pid); + return getticks(pid); +} \\ No newline at end of file /user/user.h The system call interface in user space. diff --git a/user/user.h b/user/user.h index f16fe27..f09d85b 100644 --- a/user/user.h +++ b/user/user.h @@ -22,6 +22,8 @@ int getpid(void); char* sbrk(int); int sleep(int); int uptime(void); +int settickets(int); +int getticks(int); // ulib.c int stat(const char*, struct stat*); diff --git a/user/usys.pl b/user/usys.pl index 01e426e..86af7cb 100755 --- a/user/usys.pl +++ b/user/usys.pl @@ -36,3 +36,5 @@ entry(\"getpid\"); entry(\"sbrk\"); entry(\"sleep\"); entry(\"uptime\"); +entry(\"settickets\"); +entry(\"getticks\"); \\ No newline at end of file /user/test_scheduler.c This is the test program in user space for you testing schedulers' behavior. There are several arguments for this program. SLEEP_TIME : the time in ticks you want to make the parent process to sleep. N_PROC : the count of processes you want to run for testing. TICKETN : the ticket number for different process. This parent process does three things: Create N_PROC child processes. Sleep for SLEEP_TIME ticks. KILL all child and output their execution time (in ticks). All child processes do two things: Set tickets for itself. Do a infinite while(1) loop. The expected behavior of this program is that, the parent process would output ticks for each child process and the ticks matches your scheduling strategy. Specifically, for original scheduler it should output almost same ticks for each process no matter what tickets they have and the ticks should be inversely proportinal to the number of tickets. diff --git a/user/test_scheduler.c b/user/test_scheduler.c new file mode 100644 index 0000000..23dd138 --- /dev/null +++ b/user/test_scheduler.c @@ -0,0 +1,49 @@ +#include \"kernel/types.h\" +#include \"user/user.h\" + +const int MAX_N_PROC = 1 << 5; +const int MAX_TICKETS = 1 << 10; + +int main(int argc, char **argv) { + if (argc < 4) { + printf(\"Usage: %s [SLEEP_TIME in ms] [N_PROC] [TICKET1] [TICKET2]...\\n\", argv[0]); + exit(-1); + } + int sleep_time = atoi(argv[1]); + int n_proc = atoi(argv[2]); + if (n_proc > MAX_N_PROC) { + printf(\"Error: Maximum number of processes is %d (%d received)\\n\", MAX_N_PROC, n_proc); + exit(-1); + } + int tickets[MAX_N_PROC]; + for (int i = 0; i < n_proc; i++) { + tickets[i] = atoi(argv[i + 3]); + if (tickets[i] < 1 || tickets[i] > MAX_TICKETS) { + printf(\"Error: Ticket value must be between 1 and %d (%d received)\\n\", MAX_TICKETS, tickets[i]); + exit(-1); + } + } + + int *childs = malloc(n_proc * sizeof(int)); + for (int i = 0; i < n_proc; ++i) { + int pid = fork(); + if (pid == 0) { + // Child process + settickets(tickets[i]); + while (1) ; // Infinite loop to keep the child process running + } else if (pid > 0) { + // Parent process + childs[i] = pid; + printf(\"Created child process with PID: %d and tickets: %d\\n\", pid, tickets[i]); + } else { + printf(\"Error: Fork failed\\n\"); + exit(-1); + } + } + sleep(sleep_time); + for (int i = 0; i < n_proc; ++i) { + printf(\"Child PID: %d, ticks spent: %d\\n\", childs[i], getticks(childs[i])); + kill(childs[i]); + } + return 0; +} \\ No newline at end of file Compile and Run After you are familiar to the source code modification, you can now run the test program for default RR scheduler. $ make qemu riscv64-linux-gnu-gcc -c -o kernel/entry.o kernel/entry.S ... qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 1 -nographic -global virtio-mmio.force-legacy=false -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 xv6 kernel is booting init: starting sh $ Run our test program by: $ ./test_scheduler 100 3 1024 512 256 In this test, we run 3 child processes and they have 1024, 512 and 256 tickets seperately. The expected output for this test should be closely equal ticks. The program may wait for several seconds or minutes to finish based on your CPU speed. If you see the output like following, you are ready to write your own scheduler! $ ./test_scheduler 100 3 1024 512 256 Created child process with PID: 4 and tickets: 1024 Created child process with PID: 5 and tickets: 512 Created child process with PID: 6 and tickets: 256 Child PID: 4, ticks spent: 34 Child PID: 5, ticks spent: 34 Child PID: 6, ticks spent: 34 When you finish your lottery and stride scheduler, you can compile them by: $ make clean $ make SCHEDULER=LOTTERY qemu and $ make clean $ make SCHEDULER=STRIDE qemu REMEMBER TO CLEAN whenver you want to re-compile your code. The expect output for lottery should be: $ ./test_scheduler 100 3 1024 512 256 Created child process with PID: 4 and tickets: 1024 Created child process with PID: 5 and tickets: 512 Created child process with PID: 6 and tickets: 256 Child PID: 4, ticks spent: 56 Child PID: 5, ticks spent: 32 Child PID: 6, ticks spent: 14 $ ./test_scheduler 100 3 1024 512 256 Created child process with PID: 9 and tickets: 1024 Created child process with PID: 10 and tickets: 512 Created child process with PID: 11 and tickets: 256 Child PID: 9, ticks spent: 60 Child PID: 10, ticks spent: 28 Child PID: 11, ticks spent: 15 The ticks for two different execution is likely to be different. The one for stride should be like: $ ./test_scheduler 100 3 1024 512 256 Created child process with PID: 4 and tickets: 1024 Created child process with PID: 5 and tickets: 512 Created child process with PID: 6 and tickets: 256 Child PID: 4, ticks spent: 58 Child PID: 5, ticks spent: 29 Child PID: 6, ticks spent: 14 $ ./test_scheduler 100 3 1024 512 256 Created child process with PID: 8 and tickets: 1024 Created child process with PID: 9 and tickets: 512 Created child process with PID: 10 and tickets: 256 Child PID: 8, ticks spent: 58 Child PID: 9, ticks spent: 29 Child PID: 10, ticks spent: 14 $ The ticks for two different execution is likely to be same. Try different process number, ticks and tickets and include a figure in you report like the one in stride scheduling paper.","title":"Lab 2 - Scheduler, Lottery and Stride"},{"location":"lab-tutorials/lab2/#lab-2-scheduler-lottery-and-stride","text":"","title":"Lab 2 - Scheduler, Lottery and Stride"},{"location":"lab-tutorials/lab2/#before-start","text":"Take a look at our project repo . We have a new scheduler-lab branch published. In this lab, you need implement your work based on this branch. Also, get overall idea for these two scheduling strategy: Lottery Scheduling Stride Scheduling","title":"Before Start"},{"location":"lab-tutorials/lab2/#pull-the-repo","text":"Clone the repo to your local machine. $ git clone https://github.com/gdjs2/xv6-riscv-UCR-CS202-Fall24.git Change directory and checkout to scheduler-lab branch. $ git checkout scheduler-lab If you receive error like: fatal: detected dubious ownership in repository at... just follow the instruction mark the directory as safe. Let's first see what has been done for our project.","title":"Pull the Repo"},{"location":"lab-tutorials/lab2/#makefile","text":"In Makefile , we have four mofidifcations: Add a source file and objective file random.o, which is a Linear congruential generator (LCG) for generating random numbers in lottery scheduler. Add a macro deciding which scheduler to use in compiling. Add a user space program to test different schedulers. Change the cpu counts to one. (why we need do this?) diff --git a/Makefile b/Makefile index f8c820e..b2ce8c0 100644 --- a/Makefile +++ b/Makefile @@ -28,7 +28,8 @@ OBJS = \\ $K/sysfile.o \\ $K/kernelvec.o \\ $K/plic.o \\ - $K/virtio_disk.o + $K/virtio_disk.o \\ + $K/random.o # riscv64-unknown-elf- or riscv64-linux-gnu- # perhaps in /opt/riscv/bin @@ -78,6 +79,13 @@ ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),) CFLAGS += -fno-pie -nopie endif +# Add lottery and stride scheduler +ifeq ($(SCHEDULER), LOTTERY) + CFLAGS += -DSCHEDULER=LOTTERY +else ifeq ($(SCHEDULER), STRIDE) + CFLAGS += -DSCHEDULER=STRIDE +endif + LDFLAGS = -z max-page-size=4096 $K/kernel: $(OBJS) $K/kernel.ld $U/initcode @@ -139,6 +147,7 @@ UPROGS=\\ $U/_grind\\ $U/_wc\\ $U/_zombie\\ + $U/_test_scheduler\\ fs.img: mkfs/mkfs README $(UPROGS) mkfs/mkfs fs.img README $(UPROGS) @@ -160,7 +169,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \\ then echo \"-gdb tcp::$(GDBPORT)\"; \\ else echo \"-s -p $(GDBPORT)\"; fi) ifndef CPUS -CPUS := 3 +CPUS := 1 endif QEMUOPTS = -machine virt -bios none -kernel $K/kernel -m 128M -smp $(CPUS) -nographic","title":"Makefile"},{"location":"lab-tutorials/lab2/#kerneldefsh","text":"In /kernel/defs.h , we have two modifications: 1. Add declaration for two kernel functions. void proc_set_tickets(int) is for setting tickets for current process and int getticks(int pid) is for getting ticks spent on particular process specified by pid . 2. Add function interfaces for random.o - uint random(void) for generating random numbers and void srand(uint64) for specifying the seed of randomization. diff --git a/kernel/defs.h b/kernel/defs.h index d1b6bb9..03b3d6c 100644 --- a/kernel/defs.h +++ b/kernel/defs.h @@ -106,6 +106,8 @@ void yield(void); int either_copyout(int user_dst, uint64 dst, void *src, uint64 len); int either_copyin(void *dst, int user_src, uint64 src, uint64 len); void procdump(void); +void proc_set_tickets(int); +int getticks(int pid); // swtch.S void swtch(struct context*, struct context*); @@ -187,3 +189,7 @@ void virtio_disk_intr(void); // number of elements in fixed-size array #define NELEM(x) (sizeof(x)/sizeof((x)[0])) + +// random.c +uint random(void); +void srand(uint64); \\ No newline at end of file","title":"/kernel/defs.h"},{"location":"lab-tutorials/lab2/#kernelparamh","text":"In /kernel/param.h , we defined several constants for schedulers: STRIDE1 : the total stride in stride scheduler, $2^{16}$ by default DEFAULT_TICKS : the default TICKETS for process, $2^{10}=1024$ by default. LOTTERY and STRIDE : variables for conditional compilation. diff --git a/kernel/param.h b/kernel/param.h index 80ec6d3..f998f5d 100644 --- a/kernel/param.h +++ b/kernel/param.h @@ -12,4 +12,7 @@ #define FSSIZE 2000 // size of file system in blocks #define MAXPATH 128 // maximum file path name #define USERSTACK 1 // user stack pages - +#define STRIDE1 (1<<16) // stride value for stride scheduling +#define DEFAULT_TICKS (1<<10) // default time slice for stride scheduling +#define LOTTERY 1 // lottery scheduling +#define STRIDE 2 // stride scheduling","title":"/kernel/param.h"},{"location":"lab-tutorials/lab2/#kernelprocc","text":"This is the most complex part and what you need to do is implementing two scheduler functions in this file, referring to TODO symbols.","title":"/kernel/proc.c"},{"location":"lab-tutorials/lab2/#new-member-vars","text":"We have four member variables defined in struct proc for schedulers- tickets , stride , pass and ticks . For their definition and usage, refer to the papers . --- a/kernel/proc.c +++ b/kernel/proc.c @@ -124,6 +124,10 @@ allocproc(void) found: p->pid = allocpid(); p->state = USED; + p->tickets = DEFAULT_TICKS; + p->stride = STRIDE1 / p->tickets; + p->pass = p->stride; + p->ticks = 0; // Allocate a trapframe page. if((p->trapframe = (struct trapframe *)kalloc()) == 0){ @@ -169,6 +173,10 @@ freeproc(struct proc *p) p->killed = 0; p->xstate = 0; p->state = UNUSED; + p->tickets = 0; + p->stride = 0; + p->pass = 0; + p->ticks = 0; }","title":"New Member Vars"},{"location":"lab-tutorials/lab2/#scheduler-part","text":"WHAT YOU NEED TO DO in this project is finishing the two scheduler() functions in this file and test them by provided user space program. The original void scheduler(void) function is a Round Robin (RR) scheduling. void scheduler(void) { struct proc *p; struct cpu *c = mycpu(); c->proc = 0; for(;;){ // The most recent process to run may have had interrupts // turned off; enable them to avoid a deadlock if all // processes are waiting. ... } } } The outer for(;;) loop will be launched when each cpu starts. Therefore, in the default implementation, you can find that the function keeps finding the available (i.e., RUNNABLE ) process and run it whenever the scheduler finds one. This is known as RR scheduling. It's not hard to imagine that, the processes will be executed evenly and they will have almost the same execution time. acquire(&p->lock); ... release(&p->lock); Acquire and release the process lock when you need to access/modify the members in structure p to avoid consistency issues. intr_on() is used for enabling the interrupts in OS. asm volatile(\"wfi\") is used for inserting a assembly language wfi , which puts current CPU to idle and waiting till next interrput. @@ -441,6 +449,7 @@ wait(uint64 addr) // - swtch to start running that process. // - eventually that process transfers control // via swtch back to the scheduler. +#if !defined(SCHEDULER) || (SCHEDULER != LOTTERY && SCHEDULER != STRIDE) void scheduler(void) { @@ -464,6 +473,7 @@ scheduler(void) p->state = RUNNING; c->proc = p; swtch(&c->context, &p->context); + ++p->ticks; // Increment the tick count for the process. // Process is done running for now. // It should have changed its p->state before coming back. @@ -480,6 +490,26 @@ scheduler(void) } } +#elif SCHEDULER == LOTTERY +/** + * TODO: Implement the lottery scheduler. + */ +void +scheduler(void) +{ + +} +#elif SCHEDULER == STRIDE +/** + * TODO: Implement the stride scheduler. + */ +void +scheduler(void) +{ + +} +#endif + // Switch to scheduler. Must hold only p->lock // and have changed proc->state. Saves and restores // intena because intena is a property of this @@ -693,3 +723,24 @@ procdump(void) printf(\"\\n\"); } } +","title":"Scheduler Part"},{"location":"lab-tutorials/lab2/#two-kernel-functions","text":"Two kernel functions implementation for setting tickets and getting ticks, referring here for details. +void proc_set_tickets(int tickets) { + struct proc *p = myproc(); + acquire(&p->lock); + p->tickets = tickets; + p->stride = STRIDE1 / p->tickets; + release(&p->lock); +} + +int getticks(int pid) { + struct proc *p; + for (p = proc; p < &proc[NPROC]; p++) { + acquire(&p->lock); + if (p->pid == pid) { + release(&p->lock); + return p->ticks; + } + release(&p->lock); + } + return -1; +} \\ No newline at end of file","title":"Two Kernel Functions"},{"location":"lab-tutorials/lab2/#kernelproch","text":"Add necessary attributes for structure struct proc , refer here for details. diff --git a/kernel/proc.h b/kernel/proc.h index d021857..d5e5fc5 100644 --- a/kernel/proc.h +++ b/kernel/proc.h @@ -91,6 +91,10 @@ struct proc { int killed; // If non-zero, have been killed int xstate; // Exit status to be returned to parent's wait int pid; // Process ID + uint tickets; + uint stride; + uint pass; + uint ticks; // wait_lock must be held when using this: struct proc *parent; // Parent process","title":"/kernel/proc.h"},{"location":"lab-tutorials/lab2/#kernelrandomc","text":"Source file for random number generation. You would use them in lottery scheduling. Refer here for details. diff --git a/kernel/random.c b/kernel/random.c new file mode 100644 index 0000000..53334b0 --- /dev/null +++ b/kernel/random.c @@ -0,0 +1,12 @@ +#include \"types.h\" + +static uint64 seed = 1; + +uint random(void) { + seed = seed * 6364136223846793005ULL + 1; + return (seed >> 32) & 0x7fffffff; +} + +void srand(uint64 new_seed) { + seed = new_seed; +} \\ No newline at end of file","title":"/kernel/random.c"},{"location":"lab-tutorials/lab2/#kernelsyscallc","text":"Mandatory system calls definition, you have learned them in Lab 1. diff --git a/kernel/syscall.c b/kernel/syscall.c index ed65409..217a31b 100644 --- a/kernel/syscall.c +++ b/kernel/syscall.c @@ -101,6 +101,8 @@ extern uint64 sys_unlink(void); extern uint64 sys_link(void); extern uint64 sys_mkdir(void); extern uint64 sys_close(void); +extern uint64 sys_settickets(void); +extern uint64 sys_getticks(void); // An array mapping syscall numbers from syscall.h // to the function that handles the system call. @@ -126,6 +128,8 @@ static uint64 (*syscalls[])(void) = { [SYS_link] sys_link, [SYS_mkdir] sys_mkdir, [SYS_close] sys_close, +[SYS_settickets] sys_settickets, +[SYS_getticks] sys_getticks, }; void","title":"/kernel/syscall.c"},{"location":"lab-tutorials/lab2/#kernelsyscallh","text":"Same to above. diff --git a/kernel/syscall.h b/kernel/syscall.h index bc5f356..19fc543 100644 --- a/kernel/syscall.h +++ b/kernel/syscall.h @@ -1,22 +1,24 @@ // System call numbers -#define SYS_fork 1 -#define SYS_exit 2 -#define SYS_wait 3 -#define SYS_pipe 4 -#define SYS_read 5 -#define SYS_kill 6 -#define SYS_exec 7 -#define SYS_fstat 8 -#define SYS_chdir 9 -#define SYS_dup 10 -#define SYS_getpid 11 -#define SYS_sbrk 12 -#define SYS_sleep 13 -#define SYS_uptime 14 -#define SYS_open 15 -#define SYS_write 16 -#define SYS_mknod 17 -#define SYS_unlink 18 -#define SYS_link 19 -#define SYS_mkdir 20 -#define SYS_close 21 +#define SYS_fork 1 +#define SYS_exit 2 +#define SYS_wait 3 +#define SYS_pipe 4 +#define SYS_read 5 +#define SYS_kill 6 +#define SYS_exec 7 +#define SYS_fstat 8 +#define SYS_chdir 9 +#define SYS_dup 10 +#define SYS_getpid 11 +#define SYS_sbrk 12 +#define SYS_sleep 13 +#define SYS_uptime 14 +#define SYS_open 15 +#define SYS_write 16 +#define SYS_mknod 17 +#define SYS_unlink 18 +#define SYS_link 19 +#define SYS_mkdir 20 +#define SYS_close 21 +#define SYS_settickets 22 +#define SYS_getticks 23","title":"/kernel/syscall.h"},{"location":"lab-tutorials/lab2/#kernelsysprocc","text":"System call implementations. diff --git a/kernel/sysproc.c b/kernel/sysproc.c index 3b4d5bd..e53385f 100644 --- a/kernel/sysproc.c +++ b/kernel/sysproc.c @@ -91,3 +91,23 @@ sys_uptime(void) release(&tickslock); return xticks; } + +uint64 +sys_settickets(void) +{ + int tickets; + argint(0, &tickets); + if (tickets < 1) { + return -1; + } + proc_set_tickets(tickets); + return 0; +} + +uint64 +sys_getticks(void) +{ + int pid; + argint(0, &pid); + return getticks(pid); +} \\ No newline at end of file","title":"/kernel/sysproc.c"},{"location":"lab-tutorials/lab2/#useruserh","text":"The system call interface in user space. diff --git a/user/user.h b/user/user.h index f16fe27..f09d85b 100644 --- a/user/user.h +++ b/user/user.h @@ -22,6 +22,8 @@ int getpid(void); char* sbrk(int); int sleep(int); int uptime(void); +int settickets(int); +int getticks(int); // ulib.c int stat(const char*, struct stat*); diff --git a/user/usys.pl b/user/usys.pl index 01e426e..86af7cb 100755 --- a/user/usys.pl +++ b/user/usys.pl @@ -36,3 +36,5 @@ entry(\"getpid\"); entry(\"sbrk\"); entry(\"sleep\"); entry(\"uptime\"); +entry(\"settickets\"); +entry(\"getticks\"); \\ No newline at end of file","title":"/user/user.h"},{"location":"lab-tutorials/lab2/#usertest_schedulerc","text":"This is the test program in user space for you testing schedulers' behavior. There are several arguments for this program. SLEEP_TIME : the time in ticks you want to make the parent process to sleep. N_PROC : the count of processes you want to run for testing. TICKETN : the ticket number for different process. This parent process does three things: Create N_PROC child processes. Sleep for SLEEP_TIME ticks. KILL all child and output their execution time (in ticks). All child processes do two things: Set tickets for itself. Do a infinite while(1) loop. The expected behavior of this program is that, the parent process would output ticks for each child process and the ticks matches your scheduling strategy. Specifically, for original scheduler it should output almost same ticks for each process no matter what tickets they have and the ticks should be inversely proportinal to the number of tickets. diff --git a/user/test_scheduler.c b/user/test_scheduler.c new file mode 100644 index 0000000..23dd138 --- /dev/null +++ b/user/test_scheduler.c @@ -0,0 +1,49 @@ +#include \"kernel/types.h\" +#include \"user/user.h\" + +const int MAX_N_PROC = 1 << 5; +const int MAX_TICKETS = 1 << 10; + +int main(int argc, char **argv) { + if (argc < 4) { + printf(\"Usage: %s [SLEEP_TIME in ms] [N_PROC] [TICKET1] [TICKET2]...\\n\", argv[0]); + exit(-1); + } + int sleep_time = atoi(argv[1]); + int n_proc = atoi(argv[2]); + if (n_proc > MAX_N_PROC) { + printf(\"Error: Maximum number of processes is %d (%d received)\\n\", MAX_N_PROC, n_proc); + exit(-1); + } + int tickets[MAX_N_PROC]; + for (int i = 0; i < n_proc; i++) { + tickets[i] = atoi(argv[i + 3]); + if (tickets[i] < 1 || tickets[i] > MAX_TICKETS) { + printf(\"Error: Ticket value must be between 1 and %d (%d received)\\n\", MAX_TICKETS, tickets[i]); + exit(-1); + } + } + + int *childs = malloc(n_proc * sizeof(int)); + for (int i = 0; i < n_proc; ++i) { + int pid = fork(); + if (pid == 0) { + // Child process + settickets(tickets[i]); + while (1) ; // Infinite loop to keep the child process running + } else if (pid > 0) { + // Parent process + childs[i] = pid; + printf(\"Created child process with PID: %d and tickets: %d\\n\", pid, tickets[i]); + } else { + printf(\"Error: Fork failed\\n\"); + exit(-1); + } + } + sleep(sleep_time); + for (int i = 0; i < n_proc; ++i) { + printf(\"Child PID: %d, ticks spent: %d\\n\", childs[i], getticks(childs[i])); + kill(childs[i]); + } + return 0; +} \\ No newline at end of file","title":"/user/test_scheduler.c"},{"location":"lab-tutorials/lab2/#compile-and-run","text":"After you are familiar to the source code modification, you can now run the test program for default RR scheduler. $ make qemu riscv64-linux-gnu-gcc -c -o kernel/entry.o kernel/entry.S ... qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 1 -nographic -global virtio-mmio.force-legacy=false -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 xv6 kernel is booting init: starting sh $ Run our test program by: $ ./test_scheduler 100 3 1024 512 256 In this test, we run 3 child processes and they have 1024, 512 and 256 tickets seperately. The expected output for this test should be closely equal ticks. The program may wait for several seconds or minutes to finish based on your CPU speed. If you see the output like following, you are ready to write your own scheduler! $ ./test_scheduler 100 3 1024 512 256 Created child process with PID: 4 and tickets: 1024 Created child process with PID: 5 and tickets: 512 Created child process with PID: 6 and tickets: 256 Child PID: 4, ticks spent: 34 Child PID: 5, ticks spent: 34 Child PID: 6, ticks spent: 34 When you finish your lottery and stride scheduler, you can compile them by: $ make clean $ make SCHEDULER=LOTTERY qemu and $ make clean $ make SCHEDULER=STRIDE qemu REMEMBER TO CLEAN whenver you want to re-compile your code. The expect output for lottery should be: $ ./test_scheduler 100 3 1024 512 256 Created child process with PID: 4 and tickets: 1024 Created child process with PID: 5 and tickets: 512 Created child process with PID: 6 and tickets: 256 Child PID: 4, ticks spent: 56 Child PID: 5, ticks spent: 32 Child PID: 6, ticks spent: 14 $ ./test_scheduler 100 3 1024 512 256 Created child process with PID: 9 and tickets: 1024 Created child process with PID: 10 and tickets: 512 Created child process with PID: 11 and tickets: 256 Child PID: 9, ticks spent: 60 Child PID: 10, ticks spent: 28 Child PID: 11, ticks spent: 15 The ticks for two different execution is likely to be different. The one for stride should be like: $ ./test_scheduler 100 3 1024 512 256 Created child process with PID: 4 and tickets: 1024 Created child process with PID: 5 and tickets: 512 Created child process with PID: 6 and tickets: 256 Child PID: 4, ticks spent: 58 Child PID: 5, ticks spent: 29 Child PID: 6, ticks spent: 14 $ ./test_scheduler 100 3 1024 512 256 Created child process with PID: 8 and tickets: 1024 Created child process with PID: 9 and tickets: 512 Created child process with PID: 10 and tickets: 256 Child PID: 8, ticks spent: 58 Child PID: 9, ticks spent: 29 Child PID: 10, ticks spent: 14 $ The ticks for two different execution is likely to be same. Try different process number, ticks and tickets and include a figure in you report like the one in stride scheduling paper.","title":"Compile and Run"}]}